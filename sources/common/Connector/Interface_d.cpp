// (c) Aleksandr Shevchenko e-mail : Sasha7b9@tut.by
#include "defines.h"
#include "Connector/Messages.h"
#include "Connector/Transceiver.h"
#include "Connector/Handlers_d.h"
#include "Connector/Interface_d.h"
#include "Hardware/Timer.h"
#include "Hardware/HAL/HAL.h"
#include "Utils/Queue.h"
#include "Utils/StringUtils.h"
#include <cstdlib>


namespace DInterface
{
    // Очередь сообщений, ожидающих отправки
    static Queue outbox;

    // Ненулевое значение означает, что его следует передать в панель как измеренное частотомером значение
    uint freqForSend = MAX_UINT;
}


Queue &DInterface::GetOutbox()
{
    return outbox;
}


void DInterface::ResetFreqForSend()
{
    freqForSend = MAX_UINT;
}


void DInterface::Update()
{
    int size = 0;

    if (HAL_SPI1::Receive(&size, 4))                                                            // Узнаём размер принимаемого сообщения
    {
        BaseMessage first;              // Сюда принимаем первое сообщение
        BaseMessage second;             // Сюда принимаем второе сообщение

        if (first.AllocateMemory(size))
        {
            if (HAL_SPI1::Receive(first.TakeData(), first.Size()))                         // Принимаем данные
            {
                if (HAL_SPI1::Transmit(&size, 4))                                          // Передаём его размер
                {
                    if (HAL_SPI1::Transmit(first.TakeData(), first.Size()))                // И данные
                    {
                        if (HAL_SPI1::Receive(&size, 4))
                        {
                            if (second.AllocateMemory(size))                                        // Второй раз сообщение будем принимать в этот буфер
                            {
                                if (HAL_SPI1::Receive(second.TakeData(), second.Size()))   // Что и делаем
                                {
                                    size = second.Size();

                                    if (HAL_SPI1::Transmit(&size, 4))
                                    {
                                        if (HAL_SPI1::Transmit(second.TakeData(), second.Size()))
                                        {
                                            if (second.IsEquals(&first))                            // Проверяем, совпали ли оба принятых сообщения
                                            {
                                                DHandlers::Processing(&first);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


bool DInterface::AddMessageForTransmit(BaseMessage *message)
{
    BaseMessage *clone = message->Clone();

    if (!outbox.Push(clone))
    {
        delete clone;
        // \tood Здесь нужно сообщать об ошибке. Сделать так, чтобы сообщения об ошибках обладали привилегированным статусом - помещать их в очередь даже когда там нет места (освободить)
        // LOG_ERROR("Очередь переполнена");
        return false;
    }

    return true;
}


void BaseMessage::Transmit()
{
    DInterface::AddMessageForTransmit(this);
}
